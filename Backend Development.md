По структурам таблиц

* users
* authors
* books
* readings
* achievements (etc)

Login - проверка InitData в каждом запросе

Problems
* **circular import** (частична решена, можно посмотреть пример в коде)
* 

Ссылка на пидарасов у которых пиздим книги
https://bookscloud.ru/

Телеграм авторизация
https://habr.com/ru/articles/801121/
https://habr.com/ru/articles/889270/


По задачам:
Книги по жанрам + теги
Выкачать все книги через селениум с сайта (https://bookscloud.ru/books/12782#download) приоритет -- средний (Кирилл)
Скрипт парсинга метаданных книги ()
создание бота (низкий)
- [ ] Книги по жанрам + теги
- [x] Выкачать все книги через селениум с сайта (https://bookscloud.ru/books/12782#download) приоритет -- средний (Кирилл)
- [x] Скрипт парсинга метаданных книги ()
- [x] аутентификацией/авторизация через проверку InitData
- [x] Базовые методы для User
- [ ] Чтение книги (сделана отдача по главам без лишний информации - переделать, потому что Кирилл ПИДОРАС МРАЗЬ ЧМО)
- [ ] Чтение абзацев:
- Есть константа символов целиком, например 3000
  Есть константа символов на строчку, например 100
  Таким образом у нас максималка 30 строчек
  мы смотрим книжку, если встречаем <p> длина которого меньше 100 символов - это + 1 строчка .если больше 100 символов - вставляем все целиком и считаем сумму символов на страничку. как только подберемся к 3000 отдаем собраное говно. должен быть поле offset в readings которое будет хранить последний прочитанный юзером символ (ну или последний символ который мы отдали) изначально 0, отдаем первый "абзац" - становится 3000
- [ ] создание бота (приоритет низкий)

Авторизация/аутентификация
Два варианата:
1. Работать с InitData и проверять ее при каждом запросе, реализовав проверку через Depends
2. Создавать jwt и валидировать jwt при запросах.




